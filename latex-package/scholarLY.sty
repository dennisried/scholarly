\ProvidesPackage{scholarLY}

\RequirePackage{ifthen}
\RequirePackage{enumitem}
\RequirePackage{xstring}
\RequirePackage{keyval}
\RequirePackage{stringstrings}
\RequirePackage{verbatim}% for comments
\RequirePackage{titlecaps}% for custom names

% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
%% ~ ~ ~ GLOBAL STYLING OPTIONS ~
% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% default styles:
\def\annType{}
\def\annMeasure{}
\def\annBeat{}
\def\annVoice{}
\def\annAffected{}
\def\annMessage{}
\def\annMessageO{}
\def\annMessageOO{}

% `annStyles` keys to update styles:
\define@key{annStyles}{type}{\def\annType{#1}}
\define@key{annStyles}{measure}{\def\annMeasure{#1}}
\define@key{annStyles}{beat}{\def\annBeat{#1}}
\define@key{annStyles}{voice}{\def\annVoice{#1}}
\define@key{annStyles}{affected}{\def\annAffected{#1}}
\define@key{annStyles}{message}{\def\annMessage{#1}}
\define@key{annStyles}{message-2nd}{\def\annMessageO{#1}}
\define@key{annStyles}{message-3rd}{\def\annMessageOO{#1}}

% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
%% ~ ~ ~ DRAFT or FINAL MODE, and styling therein ~
% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

\def\customdraft{}
% create custom settings for `draft` mode:
\newcommand\annSetDraft[1]{
  \def\customdraft{#1}
}

\def\customfinal{}
% create custom settings for `final` mode:
\newcommand\annSetFinal[1]{
  \def\customfinal{#1}
}

% let custom final settings carry over to draft mode:
\newcommand{\finalfordraft}{\def\customdraft{\customfinal}}

% break annotations or not:
\newcommand{\letAnnBreakornot}{\par\nobreak} % default = no break
\newcommand{\annBreakAllow}{\renewcommand{\letAnnBreakornot}{\par}} % let break
\newcommand{\annBreakAvoid}{\renewcommand{\letAnnBreakornot}{\par\nobreak}} % avoid break
%
% NOTE If \enumoptions (see below) specifies vertical spacing within items, \letAnnBreak
%      is more likely to result in breaks. Otherwise, LaTeX will try to avoid breaking
%      even with \annBreakAllow employed.
%
% apply any of the usual enumerate arguments to the list:
\newcommand{\enumOptions}{}
\newcommand{\setEnumOptions}[1]{\renewcommand{\enumOptions}{#1}}
%
% inline or stacked annotations:
\newcommand{\skipornot}{}
\newcommand{\typeSkipornot}{}

\newcommand{\annInline}{%
  \renewcommand{\skipornot}{, }
  \renewcommand{\typeSkipornot}{}
}

\newcommand{\annStacked}{%
  \renewcommand{\skipornot}{\letAnnBreakornot}
  \renewcommand{\typeSkipornot}{\letAnnBreakornot}
}

% custom type name . stub
\define@key{scholarLYannotations}{type}{\def\lytype{#1}}

\def\prependType{}% stub
\def\appendType{}% stub
\def\annType{}% stub

% hide or show annotation types:
\newcommand{\annHideType}{%
  \def\annName{}
  \renewcommand{\typeSkipornot}{}
}
\newcommand{\annShowType}{%
  \def\annName{{\annType\annTypeName }}
  \ifthenelse{\equal{\skipornot}{\letAnnBreakornot}}% (if stacked params)
    {\renewcommand{\typeSkipornot}{\letAnnBreakornot}}
    {\renewcommand{\typeSkipornot}{}}
}


\input{../default-stylesheet.inp}% TODO recheck this
\def\annStyleMode{}
\def\annRevisit{}

% PACKAGE OPTIONS:
\newif\ifDraft
  \DeclareOption{draft}{\Drafttrue}
  \DeclareOption{final}{\Draftfalse}

\newif\ifDefault
  \DeclareOption{default}{\Defaulttrue}
  \DeclareOption{custom}{\Defaultfalse}

\ProcessOptions*
%
% use final (implicit) or draft:
\ifDraft
  \def\annStyleMode{\customdraft}
  \def\annRevisit{\revisitDraftorNot}
\else
  \def\annStyleMode{\customfinal}
  \def\annRevisit{\revisitFinalorNot}
\fi

\ifDefault
  \def\revisitFinalorNot{\defaultFinal}
  \def\revisitDraftorNot{\defaultDraft}
\else
  \def\revisitFinalorNot{}
  \def\revisitDraforNot{}
\fi


%% ~ ~ ~ ADDITIONAL CUSTOMIZATIONS ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% do something immediately after the type (only effective if type present)
\def\annPostType{}
\define@key{annPrefixes}{post-type}{\def\annPostType{#1}}
% for example, could be used to add vspace, hspace, characters, etc. after type

% do something immediately before each type or arg (arg presently affects all):
\def\annTypePrePrefix{}
\define@key{annPrefixes}{pre-type}{\def\annTypePrePrefix{#1}}
\def\annArgsPrePrefix{}
\define@key{annPrefixes}{pre-args}{\def\annArgsPrePrefix{#1}}

% first message wrapper (goes inside ann-footnote)
\def\prependMessage{}
\def\appendMessage{}
\def\aMWSep{/}
% to redefine the seperator
\newcommand\annMessageWrapSep[1]{\def\aMWSep{#1}}
%
\newcommand\annMessageWrap[1]{
  \expandarg\IfSubStr{#1}{\aMWSep}
    {\StrCut{#1}{\aMWSep}\prependMessage\appendMessage}
    {\def\prependMessage{#1}
    \def\appendMessage{#1}}
}

% complete message wrapper
\def\prependMessageFirst{}
\def\appendMessageLast{}
\def\aMWOSep{/}
% to redefine the seperator
\newcommand\annMessageWrapOuterSep[1]{\def\aMWOSep{#1}}
%
\newcommand\annMessageWrapOuter[1]{
  \expandarg\IfSubStr{#1}{\aMWOSep}
    {\StrCut{#1}{\aMWOSep}\prependMessageFirst\appendMessageLast}
    {\def\prependMessageFirst{#1}
    \def\appendMessageLast{#1}}
}

% ann type wrapper
\def\prependType{}
\def\appendType{}
\def\aTWSep{/}
% to redefine the seperator
\newcommand\annTypeWrapSep[1]{\def\aTWSep{#1}}
%
\newcommand\annTypeWrap[1]{
  \expandarg\IfSubStr{#1}{\aTWSep}
    {\StrCut{#1}{\aTWSep}\prependType\appendType}
    {\def\prependType{#1}
    \def\appendType{#1}}
}

%% ~ ~ ~ \annotations = the main command ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
\newcommand{\annotations}[1]
{\begin{enumerate}[mode=boxed]\enumOptions\annStyleMode\annRevisit\input{#1}\end{enumerate}}


% keys originally set in arg 1, exported from lilypond
\define@key{scholarLYannotations}{grob}{\edef\lygrob{\detokenize{#1}}}
\define@key{scholarLYannotations}{grob-location}{\edef\lygroblocation{\detokenize{#1}}}
\define@key{scholarLYannotations}{grob-type}{\def\lygrobtype{#1}}
\define@key{scholarLYannotations}{input-file-name}{\def\lyinputfilename{#1}}
\define@key{scholarLYannotations}{context-id}{\def\lycontextid{#1}}
\define@key{scholarLYannotations}{location}{\edef\lylocation{\detokenize{#1}}}
\define@key{scholarLYannotations}{message}{\def\lymessage{#1}}
\define@key{scholarLYannotations}{type}{\def\lyanntype{#1}}
\define@key{scholarLYannotations}{context}{\def\lycontext{#1}}
\define@key{scholarLYannotations}{ann-footnote}{\def\lyannfootnote{#1}}

\def\resetkeys{
  \setkeys{scholarLYannotations}{% default values
    grob = no value given,
    grob-location = no value given,
    grob-type = no value given,
    input-file-name = no value given,
    context-id = no value given,
    location = no value given,
    type = no value given,
    message = no value given,
    context = no value given,
    ann-footnote = {no value given}
  }
}

\def\noMessError{\color{red} Oops! No message has been entered for this annotation.}


% default Prefixes
\def\annGrobPrx{}
\def\annGrobLocationPfx{}
\def\annGrobTypePfx{}
\def\lyinputfilenamePfx{}
\def\lycontextidPfx{}
\def\annLocationPfx{}
\def\annTypePfx{}
\def\annMessagePfx{}
\def\annContextPfx{}
\def\annMeasurePfx{M.}
\def\annBeatPfx{beat }

% key family/names for overrides
\define@key{annPrefixes}{grob}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{grob-location}{\def\annGrobLocationPfx{#1}}
\define@key{annPrefixes}{grob-type}{\def\annGrobTypePfx{#1}}
\define@key{annPrefixes}{input-file-name}{\def\annInputFileNamePfx{#1}}
\define@key{annPrefixes}{context-id}{\def\annContextIDPfx{#1}}
\define@key{annPrefixes}{location}{\def\annLocationPfx{#1}}
\define@key{annPrefixes}{type}{\def\annTypePfx{#1}}
\define@key{annPrefixes}{message}{\def\annMessagePfx{#1}}
\define@key{annPrefixes}{context}{\def\annContextPfx{#1}}
\define@key{annPrefixes}{measure}{\def\annMeasurePfx{#1}}
\define@key{annPrefixes}{beat}{\def\annBeatPfx{#1}}


% if same measure, optionally substitute:
\def\previousMeasure{0}
\def\currentMeasure{0}
\def\sameMeasureStub{---}% default.. is redefined by key:
\define@key{annExtras}{same-measure}{\def\sameMeasureStub{#1}}

% optionally substitute same beat (if *also* same measure)
\def\previousBeat{0}
\def\currentBeat{0}
\def\sameBeatStub{{---}\unskip}% default.. is redefined by key:
\define@key{annExtras}{same-beat}{\def\sameBeatStub{#1}}


% to sub same (measure, or measure+beat (never just beat)) when same:
\def\sameLocationLoose{
  \ifthenelse{\equal{\currentBeat}{\previousBeat}}% if same beat
    %true
    {\ifthenelse{\equal{\currentMeasure}{\previousMeasure}}% if same measure
      {% hide measure, hide beat (w/nothing)
      \def\thisMeasure{\sameMeasureStub}
      \def\thisBeat{}
      }
      {% display measure, hide beat
      \def\thisMeasure{\annMeasurePfx\currentMeasure,}
      \def\thisBeat{\annBeatPfx\currentBeat}
      }
    }
    {% different beat
      \ifthenelse{\equal{\currentMeasure}{\previousMeasure}}
        {
        \def\thisMeasure{\sameMeasureStub}
        \def\thisBeat{\annBeatPfx\currentBeat}
        }
        {
        \def\thisMeasure{\annMeasurePfx\currentMeasure,}
        \def\thisBeat{\annBeatPfx\currentBeat}
        }
    }
}

% to sub same ONLY when both same:
\def\sameLocationStrict{
  \ifthenelse{\equal{\currentMeasure}{\previousMeasure}}% if measure same..
    % true
    {\ifthenelse{\equal{\currentBeat}{\previousBeat}}% and beat same..
      {% hide measure, hide beat (w/nothing)
      \def\thisMeasure{\sameMeasureStub}
      \def\thisBeat{\unskip}% no need to show
      }
      {% else, show both
      \def\thisMeasure{\annMeasurePfx\currentMeasure,}
      \def\thisBeat{\annBeatPfx\currentBeat}
      }
    }
    {% else, show both
    \def\thisMeasure{\annMeasurePfx\currentMeasure,}
    \def\thisBeat{\annBeatPfx\currentBeat}
    }
}

% to always show both
\def\sameLocationShow{
  \def\thisMeasure{\annMeasurePfx\currentMeasure,}
  \def\thisBeat{\annBeatPfx\currentBeat}
}

\def\annSameLocationShow{\def\testLocation{\sameLocationShow}}
\def\annSameLocationStrict{\def\testLocation{\sameLocationStrict}}
\def\annSameLocationLoose{\def\testLocation{\sameLocationLoose}}
\annSameLocationShow% default

%% ~ ~ ~ the PARSERS ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% determine if there are custom footnotes, by searching arg #1
% (\bigmessage is defined by arg #1 for each annotation)
\def\customFootsParse{
  \StrCount{\bigmessage}{-text=}[\howmanytext]
  \StrCount{\bigmessage}{ann-footnote=}[\howmanyannfn]
  % IF how many ann-footnote = 0
  \ifthenelse{\equal{\howmanyannfn}{0}}{
    \ifthenelse{\equal{\howmanytext}{0}}
      % yes, creat redundant (empty) defs, for testing; remove later
      {
      \def\resultOne{}
      \def\resultTwo{}
      \def\resultThree{}
      \def\resultFour{}
      \def\resultFive{}
      }
      % no
      {\ifthenelse{\equal{\howmanytext}{1}}
        % yes...
        {%
        \StrBehind[1]{\bigmessage}{-text=}[\resultOne]
        \def\resultTwo{}
        \def\resultThree{}
        \def\resultFour{}
        \def\resultFive{}
        }
        % no
        {\ifthenelse{\equal{\howmanytext}{2}}
          % yes
          {%
          \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
            \StrGobbleRight{\resultOne}{2}[\resultOne]
          \StrBehind[2]{\bigmessage}{-text=}[\resultTwo]
          \def\resultThree{}
          \def\resultFour{}
          \def\resultFive{}
          }
          % no
          {\ifthenelse{\equal{\howmanytext}{3}}
            % yes
            {%
            \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
              \StrGobbleRight{\resultOne}{2}[\resultOne]% removes comma
            \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
              \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
            \StrBehind[3]{\bigmessage}{-text=}[\resultThree]
            \def\resultFour{}
            \def\resultFive{}
            }
            % no
            {\ifthenelse{\equal{\howmanytext}{4}}
              % yes
              {%
              \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
                \StrGobbleRight{\resultOne}{2}[\resultOne]% removes comma
              \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
                \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
              \StrBetween[3,4]{\bigmessage}{-text=}{fn-}[\resultThree]
                \StrGobbleRight{\resultThree}{2}[\resultThree]% same...
              \StrBehind[4]{\bigmessage}{-text=}[\resultFour]
              \def\resultFive{}
              }
              % no
              {\ifthenelse{\equal{\howmanytext}{5}}
                % yes
                {%
                \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
                  \StrGobbleRight{\resultOne}{2}[\resultOne]% same...
                \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
                  \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
                \StrBetween[3,4]{\bigmessage}{-text=}{fn-}[\resultThree]
                  \StrGobbleRight{\resultThree}{2}[\resultThree]% same...
                \StrBetween[4,5]{\bigmessage}{-text=}{fn-}[\resultFour]
                  \StrGobbleRight{\resultFour}{2}[\resultFour]% same...
                \StrBehind[5]{\bigmessage}{-text=}[\resultFive]
                }
                % no
                {}% stop here? yes while it is only in proof stage
              }
            }
          }
        }
      }
    }
    % else... there IS an ann-footnote
    {\ifthenelse{\equal{\howmanytext}{0}}
      % yes
      {%
      \def\resultOne{}
      \def\resultTwo{}
      \def\resultThree{}
      \def\resultFour{}
      \def\resultFive{}
      }
      % no
      {\ifthenelse{\equal{\howmanytext}{1}}
        % yes
        {%
        \StrBetween[1,1]{\bigmessage}{-text=}{, ann-footnote}[\resultOne]
        \def\resultTwo{}
        \def\resultThree{}
        \def\resultFour{}
        \def\resultFive{}
        }
        % no
        {\ifthenelse{\equal{\howmanytext}{2}}
          % yes
          {%
          \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
          \StrBetween[2,1]{\bigmessage}{-text=}{ann-footnote}[\resultTwo]
          \def\resultThree{}
          \def\resultFour{}
          \def\resultFive{}
          }
          % no
          {\ifthenelse{\equal{\howmanytext}{3}}
            % yes
            {%
            \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
            \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
            \StrBetween[3,1]{\bigmessage}{-text=}{ ann-footnote}[\resultThree]
            \def\resultFour{}
            \def\resultFive{}
            }
            % no
            {\ifthenelse{\equal{\howmanytext}{4}}
              % yes
              {%
              \StrBetween[1,2]{\bigmessage}{-text=}{, fn-}[\resultOne]
              \StrBetween[2,3]{\bigmessage}{-text=}{, fn-}[\resultTwo]
              \StrBetween[3,4]{\bigmessage}{-text=}{, fn-}[\resultThree]
              \StrBetween[4,1]{\bigmessage}{-text=}{, ann-footnote}[\resultFour]
              \def\resultFive{}
              }
              % no
              {\ifthenelse{\equal{\howmanytext}{5}}
                % yes
                {%
                \StrBetween[1,2]{\bigmessage}{-text=}{, fn-}[\resultOne]
                \StrBetween[2,3]{\bigmessage}{-text=}{, fn-}[\resultTwo]
                \StrBetween[3,4]{\bigmessage}{-text=}{, fn-}[\resultThree]
                \StrBetween[4,5]{\bigmessage}{-text=}{, fn-}[\resultFour]
                \StrBetween[5,1]{\bigmessage}{-text=}{, ann-footnote}[\resultFive]
                }
                % no
                {%
                \def\resultOne{}
                \def\resultTwo{}
                \def\resultThree{}
                \def\resultFour{}
                \def\resultFive{}
                }% stop here? yes while it is only in proof stage...
              }
            }
          }
        }
      }
    }
}


% define the macro names for custom footnotes:
\def\extractFNnames{%
  \expandarg\StrCount{\bigmessage}{fn-}[\theFNnum]
  \ifthenelse{\equal{\theFNnum}{0}}
    {%
    \def\resultOneMacro{}
    \def\resultTwoMacro{}
    \def\resultThreeMacro{}
    \def\resultFourMacro{}
    \def\resultFiveMacro{}
    }% don't make any macro names
    {\ifthenelse{\equal{\theFNnum}{1}}
      {%
      \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
        \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
      \def\resultTwoMacro{}
      \def\resultThreeMacro{}
      \def\resultFourMacro{}
      \def\resultFiveMacro{}
      }
      {\ifthenelse{\equal{\theFNnum}{2}}
        {%
        \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
          \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
        \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
          \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
        \def\resultThreeMacro{}
        \def\resultFourMacro{}
        \def\resultFiveMacro{}
        }
        {\ifthenelse{\equal{\theFNnum}{3}}
          {%
          \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
            \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
          \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
            \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
          \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
            \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
          \def\resultFourMacro{}
          \def\resultFiveMacro{}
          }
          {\ifthenelse{\equal{\theFNnum}{4}}
            {%
            \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
              \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
            \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
              \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
            \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
              \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
            \StrBetween[4,4]{\bigmessage}{fn-}{-text=}[\resultFourMacro]
              \StrDel{\resultFourMacro}{-}[\resultFourMacro]% remove hyphens
            \def\resultFiveMacro{}
            }
            {\ifthenelse{\equal{\theFNnum}{5}}
              {%
              \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
                \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
              \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
                \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
              \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
                \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
              \StrBetween[4,4]{\bigmessage}{fn-}{-text=}[\resultFourMacro]
                \StrDel{\resultFourMacro}{-}[\resultFourMacro]% remove hyphens
              \StrBetween[5,5]{\bigmessage}{fn-}{-text=}[\resultFiveMacro]
                \StrDel{\resultFiveMacro}{-}[\resultFiveMacro]% remove hyphens
              }
              {there must be too many}% NOTE this is a STUB
            }
          }
        }
      }
    }
}


% create the macros that are used in the messages:
\def\makeFNmacros{
  \ifthenelse{\equal{\theFNnum}{0}}
    {}% don't make any macros
    {\ifthenelse{\equal{\theFNnum}{1}}
      % yes
      {%
      \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
      }
      % no
      {\ifthenelse{\equal{\theFNnum}{2}}
        % yes
        {%
        \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
        \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }
        }
        % no
        {\ifthenelse{\equal{\theFNnum}{3}}
          % yes
          {%
          \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
          \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }
          \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
          }
          % no
          {\ifthenelse{\equal{\theFNnum}{4}}
            % yes
            {%
            \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
            \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }        \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
            \expandafter\def\csname fn\resultFourMacro\endcsname{\footnote{\resultFour} }
            }
            % no
            {\ifthenelse{\equal{\theFNnum}{5}}
              % yes
              {%
              \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
              \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }        \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
              \expandafter\def\csname fn\resultFourMacro\endcsname{\footnote{\resultFour} }
              \expandafter\def\csname fn\resultFiveMacro\endcsname{\footnote{\resultFive} }
              }
              % no
              {}%stop here? yes, while it is only in proof stage
            }
          }
        }
      }
    }
}


\def\annMessagePunct{}% default, no punctuation

% test the message for punctuations, and store the result:
\newcommand{\testMessagePunct}{%
  \IfEndWith{\lymessage}{.}
    % true
    {\def\annMessagePunct{.}}
    % false
    {\IfEndWith{\lymessage}{?}
      % true
      {\def\annMessagePunct{?}}
      % false
      {\IfEndWith{\lymessage}{!}
        % true
        {\def\annMessagePunct{!}}
        % false
        {\def\annMessagePunct{\unskip}}
      }
    }
}


% parse messages:
\newcommand{\annMessageParse}{%
  \IfEndWith{\lymessage}{.}
    % true; the user set a period for punctuation
    {%
    \StrGobbleRight{\lymessage}{1}[\lymessage]
      \annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak
    }
    % false
    {\IfEndWith{\lymessage}{?}
      % true; the user set a question mark for punctuation
      {%
      \StrGobbleRight{\lymessage}{1}[\lymessage]
        \annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak
      }
      % false
      {\IfEndWith{\lymessage}{!}
        % true; the user set an exclamation point for punctuation
        {%
        \StrGobbleRight{\lymessage}{1}[\lymessage]
          \annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak
        }
        % false
        {\ifthenelse{\equal{\lymessage}{no value given}}{\unskip\noMessError}
          % else
          {\ifthenelse{\equal{\lymessage}{}}{\unskip\noMessError}
            % else
            {\annMessageOO{\annMessageO{\annMessage\prependMessage\lymessage}}\nobreak}
          }
        }
      }
    }
}


% set the append/punct vs. punct/append orientations:
\newcommand{\annMessTail}{\annMessageOO{\annMessageO{\annMessage\annMessagePunct\appendMessage}}} % default = Punct, Append

% user command, set order: punct, append
\newcommand{\annMessPunctAppend}{%
  \renewcommand{\annMessTail}{\annMessageOO{\annMessageO{\annMessage\annMessagePunct\unskip\appendMessage}}}}

% set order: append, punct
\newcommand{\annMessAppendPunct}{%
  \renewcommand{\annMessTail}{\annMessageOO{\annMessageO{\annMessage\appendMessage\unskip\annMessagePunct}}}}


% get type from key
\def\annTypeName{%
  \StrSubstitute{\lyanntype}{-}{ }[\annTypeCleaned]
  \prependType\titlecap{\annTypeCleaned}\appendType
}


% default annotation parsers: for stacked and inline modes that can be easily
% hacked/reconfigured to custom designs.

\let\KV@errx@ORI\KV@errx% store original error handling for unknown keys

% default annotation parser
%
\newcommand\annotationParse[3]{
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION, MEASURE and BEAT
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
  \testLocation
% APPLY to ITEM
  \item{
    \annTypePrePrefix\annTypePfx\annName\annPostType\typeSkipornot
    {\annArgsPrePrefix\annLocationPfx{\annMeasure{\thisMeasure}}}
    {\annBeat{\thisBeat}\skipornot}
    \ifthenelse{\equal{\lycontextid}{}}
      {\unskip{}}
      {\annArgsPrePrefix\annContextPfx\annVoice{\lycontextid}\skipornot}
    \ifthenelse{\equal{\lygrobtype}{}}
      {\unskip{}}
      {\annArgsPrePrefix\annGrobTypePfx\annAffected{\lygrobtype}\skipornot}
    \annArgsPrePrefix\annMessagePfx{{{%
      \prependMessageFirst\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}
        {}
        {\unskip{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
  \def\previousMeasure{#2}
  \def\previousBeat{#3}
}


% critical remark:
\newcommand{\criticalRemark}[3][]{%
  \annotationParse{#1}{#2}{#3}
}
% musical issue:
\newcommand{\musicalIssue}[3][]{%
  \annotationParse{#1}{#2}{#3}
}
% lilypond issue:
\newcommand{\lilypondIssue}[3][]{%
  \annotationParse{#1}{#2}{#3}
}
% question:
\newcommand{\annotateQuestion}[3][]{%
  \annotationParse{#1}{#2}{#3}
}
% todo:
\newcommand{\annotateTodo}[3][]{%
  \annotationParse{#1}{#2}{#3}
}
% generic annotations:
\newcommand{\annotation}[3][]{% generic annotation, for custom types
  \annotationParse{#1}{#2}{#3}
}



\begin{comment}

. . . . . . . . . . THIS FUNCTION NOT READY YET . . . . . . . . . . .

[The use of custom footnotes causes compilation to fail.
Function will be updated to handle custom footnotes soon enough.]

~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% for the entirely custom command: \useCustomAnn{ ... custom stuff ... }
% NOTE this is really just a placeholder right now..

\newcommand{\customannotations}[3]{
  \expandafter{#1}
  \input{#2}
  \expandafter{#3}
}

\newcommand\useCustomAnn[1]{
  \renewcommand\criticalRemark[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\musicalIssue[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\lilypondIssue[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotateQuestion[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotateTodo[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotation[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
}

\end{comment}
