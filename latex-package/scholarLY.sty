\ProvidesPackage{scholarLY}

\RequirePackage{ifthen}
\RequirePackage{enumitem}
\RequirePackage{xstring}
\RequirePackage{keyval}
\RequirePackage{stringstrings}
\RequirePackage{verbatim}% for comments
\RequirePackage{titlecaps}% for custom names


\begin{comment}
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
compiles with:
\pdflatex? YES
\lualatex? YES
\xelatex?

% TODO:
- consider reorganizing package structure (this file master, with subfiles)
- provide labels (which can be easily redefined) for user-customized templates
- support not-yet-defined footnote names
- check need for titlecap in custom annotation names
- types shouldn't always be parenthesized
~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
\end{comment}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OPTIONS ... the customizable part of the package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Some options can be applied by wrapping the \annotations{filename.annotations.inp} in
% respective environment, such as {multicols}, {xcolor}, etc.
%
% If specific changes are made to items within the text of the actual .inp lists (written
% by the user in the LilyPond document), they will override wrappers as applicable.


% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
%% ~ ~ ~ GLOBAL STYLING OPTIONS ~
% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


% styles:

\newcommand{\annType}{} % Annotation Type; just italics
\newcommand{\annMeasure}{} % just bold
\newcommand{\annBeat}{} % none
\newcommand{\annVoice}{} % none ; this is Voice or Instrument (e.g. Viola)
\newcommand{\annAffected}{} % none
\newcommand{\annMessage}{} % none
\newcommand{\annFootnote}{} % none

% To update styles:

\newcommand{\annStyleType}[1]{\renewcommand{\annType}[1]{#1}}
\newcommand{\annStyleMeasure}[1]{\renewcommand{\annMeasure}[1]{#1}}
\newcommand{\annStyleBeat}[1]{\renewcommand{\annBeat}[1]{#1}}
\newcommand{\annStyleVoice}[1]{\renewcommand{\annVoice}[1]{#1}}
\newcommand{\annStyleAffected}[1]{\renewcommand{\annAffected}[1]{#1}}
\newcommand{\annStyleMessage}[1]{\renewcommand{\annMessage}[1]{#1}}
\newcommand{\annStyleFootnote}[1]{\renewcommand{\annFootnote}[1]{#1}}
%
% ex: \styleAnnType{\textit{#1}}


% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
%% ~ ~ ~ DRAFT or FINAL MODE, and styling therein ~
% ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~


% create custom settings for `draft` mode:

\newcommand{\customdraft}{}
\newcommand\setcustomdraft[1]{\renewcommand{\customdraft}{#1}}
  \setcustomdraft{
    \styleAnnMessage{##1}
  } % the default settings for DRAFT mode = nothing

\def\customdraftornot{}
\newcommand{\usecustomdraft}{\def\customdraftornot{\customdraft}}


% create custom settings for `final` mode:

\newcommand{\customfinal}{}
\newcommand\setcustomfinal[1]{\renewcommand{\customfinal}{#1}}
  \setcustomfinal{
    \styleAnnMessage{##1}
    \styleAnnMeasure{\color{red}{\textit{##1}}}
  } % the default settings for FINAL mode (just example for now; make bland later)

\def\customfinalornot{}
\newcommand{\usecustomfinal}{\def\customfinalornot{\customfinal}} % apply custom


% let custom final settings carry over to draft mode

\newcommand{\finalfordraft}{\renewcommand{\customdraft}{\customfinal}}


% break annotations or not:

\newcommand{\letAnnBreakornot}{\par\nobreak} % default = no break
\newcommand{\letAnnBreak}{\renewcommand{\letAnnBreakornot}{\par}} % let break
\newcommand{\avoidAnnBreak}{\renewcommand{\letAnnBreakornot}{\par\nobreak}} % avoid break
%
% NOTE If \enumoptions (see below) specifies vertical spacing within items, \letAnnBreak
%      is more likely to result in breaks. Otherwise, LaTeX will try to avoid breaking
%      even with \letAnnBreak employed.


% inline or stacked annotations:

\newcommand{\skipornot}{}
\newcommand{\typeSkipornot}{}

\newcommand{\inlineParams}{%
  \renewcommand{\skipornot}{, }
}

\newcommand{\stackedParams}{%
  \renewcommand{\skipornot}{\letAnnBreakornot}
}


% custom type name . stub
\define@key{scholarLYannotations}{type}{\def\lytype{#1}}


% hide or show annotation types:

\newcommand{\hideAnnTypes}{%
  \renewcommand{\CRname}{}
  \renewcommand{\MIname}{}
  \renewcommand{\LIname}{}
  \renewcommand{\Qname}{}
  \renewcommand{\TDname}{}
  \def\customName{}
  \renewcommand{\typeSkipornot}{}
}

\newcommand{\showAnnTypes}{%
  \renewcommand{\CRname}{\annType{(Critical Remark) }} % if the user defines a ','
  \renewcommand{\MIname}{\annType{(Musical Issue) }}   % for \postannType, they must
  \renewcommand{\LIname}{\annType{(LilyPond Issue) }}  % also \unskip to remove the
  \renewcommand{\Qname}{\annType{(Question) }}         % cushion here.
  \renewcommand{\TDname}{\annType{(To Do) }}
  \def\customName{\lytype}% TODO this actually needs to be parsed
}

\newcommand{\annStyleMode}{}


% declare draft/final options:

\newif\ifex@draft % (implicitly final) ... i.e. draft mode if set, otherwise final mode,
                  % which can also be explicitly set: \usepackage[final]{scholarLY}

\DeclareOption{draft}{\ex@drafttrue}
\DeclareOption{final}{\ex@draftfalse}
\ProcessOptions*

\ifex@draft
  \stackedParams % default, can be overwritten in custom or global settings
  \newcommand{\CRname}{\annType{(Critical Remark) }}
  \newcommand{\MIname}{\annType{(Musical Issue) }}
  \newcommand{\LIname}{\annType{(LilyPond Issue) }}
  \newcommand{\Qname}{\annType{(Question) }}
  \newcommand{\TDname}{\annType{(TODO) }}
  \renewcommand{\annStyleMode}{\customdraftornot}% must be *last*
\else
  \inlineParams % default, can be overwritten in custom or global settings
  \newcommand{\CRname}{\annType{}}
  \newcommand{\MIname}{\annType{}}
  \newcommand{\LIname}{\annType{}}
  \newcommand{\Qname}{\annType{}}
  \newcommand{\TDname}{\annType{}}
  \renewcommand{\annStyleMode}{\customfinalornot}% must be *last*
\fi


%% ~ ~ ~ ADDITIONAL CUSTOMIZATIONS ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% apply any of the usual enumerate arguments to the list:

\newcommand{\enumOptions}{}
\newcommand{\setEnumOptions}[1]{\renewcommand{\enumOptions}{#1}}


% do something immediately after the type (only effective if type present)

\newcommand{\postannType}{} % add vspace, hspace, characters, etc. *after* type
\newcommand{\setpostannType}[1]{\renewcommand{\postannType}{#1}}
%
% NOTE: add \par to correct vspace behavior, i.e. \setpostannType{\par\vspace{1cm}}


% do something immediately before each of the arguments (presently affects all):

\def\preannType{}
\newcommand{\setpreannType}[1]{\def\preannType{#1}}
\def\preannArg{}
\newcommand{\setpreannArg}[1]{\def\preannArg{#1}}


% {prependFirst}{prepend} (MESSAGE) {append} {appendLast}:

\def\prependMessageFirst{}
\def\prependMessage{``} % default
\def\appendMessage{''} % default
\def\appendMessageLast{}
% user commands:
\newcommand{\setPreMessFirst}[1]{\def\prependMessageFirst{\unskip#1}}
\newcommand{\setPreMess}[1]{\def\prependMessage{#1\unskip}}
\newcommand{\setAppMess}[1]{\def\appendMessage{\unskip#1\unskip}}
\newcommand{\setAppMessLast}[1]{\def\appendMessageLast{\unskip#1\unskip}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ENVIRONMENTS and COMMANDS ... the main part of the package
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% ~ ~ ~ ALLOW (default) or AVOID breaking arguments in annotations ~ ~ ~ ~ ~ ~

% TODO - find a better solution?

% Currently, \skipornot (the main breaking toggle) = {\par\nobreak} when set to
% skip, which does protect from breaking. But rather than stretching/squeezing
% the lines, it rounds down (if necessary) and pulls the footnotes (if any) up.

% the following *will* toggle breaking allowance/avoidance
% ex: \letAnnBreak


%% ~ ~ ~ \annotations = the main command ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

\newcommand{\annotations}[1]
{\begin{enumerate}[mode=boxed]\enumOptions\annStyleMode\input{#1}\end{enumerate}}
%
% ex: \annotations{annotate.annotations.inp}


%% ~ ~ ~ KEY / VALUE arguments ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

\define@key{scholarLYannotations}{grob}{\edef\lygrob{\detokenize{#1}}}
\define@key{scholarLYannotations}{grob-location}{\edef\lygroblocation{\detokenize{#1}}}
\define@key{scholarLYannotations}{grob-type}{\def\lygrobtype{#1}}
\define@key{scholarLYannotations}{input-file-name}{\def\lyinputfilename{#1}}
\define@key{scholarLYannotations}{context-id}{\def\lycontextid{#1}}
\define@key{scholarLYannotations}{location}{\edef\lylocation{\detokenize{#1}}}
\define@key{scholarLYannotations}{message}{\def\lymessage{#1}}
\define@key{scholarLYannotations}{type}{\def\lyanntype{#1}}
\define@key{scholarLYannotations}{context}{\def\lycontext{#1}}
\define@key{scholarLYannotations}{ann-footnote}{\def\lyannfootnote{#1}}

\def\resetkeys{
  \setkeys{scholarLYannotations}{% default values
    grob = no value given,
    grob-location = no value given,
    grob-type = no value given,
    input-file-name = no value given,
    context-id = no value given,
    location = no value given,
    type = no value given,
    message = no value given,
    context = no value given,
    ann-footnote = {no value given}
  }
}

\def\noMessError{\color{red} Oops! No message has been entered for this annotation.}


% default Prefixes
\def\annGrobLocationPfx{}
\def\annGrobTypePfx{}
\def\lyinputfilenamePfx{}
\def\lycontextidPfx{}
\def\annLocationPfx{}
\def\annTypePfx{}
\def\annMessagePfx{}
\def\annContextPfx{}
\def\annMeasurePfx{M.} % default; user resets: \def\annMessagePfx{(something else)}
\def\annBeatPfx{beat }

\define@key{annPrefixes}{grob}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{grob-location}{\def\annGrobLocationPfx{#1}}
\define@key{annPrefixes}{grob-type}{\def\annGrobTypePfx{#1}}
\define@key{annPrefixes}{input-file-name}{\def\annInputFileNamePfx{#1}}
\define@key{annPrefixes}{context-id}{\def\annContextIDPfx{#1}}
\define@key{annPrefixes}{location}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{type}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{message}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{context}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{measure}{\def\annGrobPfx{#1}}
\define@key{annPrefixes}{beat}{\def\annBeatPfx{#1}}


% if same measure, optionally substitute:

\def\previousMeasure{0}
\def\sameMeasureStub{---}
\def\sameMeasure{\sameMeasureStub} % user may redefine sameMeasureStub
\def\currentMeasure{0}
\newcommand{\verboseMeasures}{\def\sameMeasure{\annMeasurePfx\currentMeasure,}}
% \verboseMeasures = makes measures always show


% optionally substitute same beat (if *also* same measure):

\def\previousBeat{0}
\def\sameBeatStub{{---}\unskip}
\def\sameBeat{\sameBeatStub}
\def\currentBeat{0}
\newcommand{\verboseBeats}{\def\sameBeat{\annBeatPfx\currentBeat}}

\ifthenelse{\equal{\sameMeasure}{\annMeasurePfx\currentMeasure,}}% if verbose measures
  %true
  {\ifthenelse{\equal{\currentBeat}{\previousBeat}}% if current beat = previous beat
    %true
    {\ifthenelse{\equal{\sameBeat}{\annBeatPfx\currentBeat}}% if verbose beats
      %true
      {\def\sameBeat{\currentBeat}}% then, beats always = current beat
      %false
      {\def\sameBeat{\sameBeatStub}}}% else, same beats = stub
    %false
    {}}% do nothing.. current beat displayed always
  %false
  {}% else nothing


%% ~ ~ ~ the PARSERS ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

%
%%
%%%%
%%%%%
% FOOTNOTES

% generic \bigmessage is replaced by arg#1 in \annotation parsers
%\def\bigmessage{}% leave this first


% determine if there are custom footnotes, by searching arg #1

\def\customFootsParse{
  \StrCount{\bigmessage}{-text=}[\howmanytext]
  \StrCount{\bigmessage}{ann-footnote=}[\howmanyannfn]
  % IF how many ann-footnote = 0
  \ifthenelse{\equal{\howmanyannfn}{0}}{
    \ifthenelse{\equal{\howmanytext}{0}}
      % yes, creat redundant (empty) defs, for testing; remove later
      {
      \def\resultOne{}
      \def\resultTwo{}
      \def\resultThree{}
      \def\resultFour{}
      \def\resultFive{}
      }
      % no
      {\ifthenelse{\equal{\howmanytext}{1}}
        % yes...
        {%
        \StrBehind[1]{\bigmessage}{-text=}[\resultOne]
        \def\resultTwo{}
        \def\resultThree{}
        \def\resultFour{}
        \def\resultFive{}
        }
        % no
        {\ifthenelse{\equal{\howmanytext}{2}}
          % yes
          {%
          \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
            \StrGobbleRight{\resultOne}{2}[\resultOne]
          \StrBehind[2]{\bigmessage}{-text=}[\resultTwo]
          \def\resultThree{}
          \def\resultFour{}
          \def\resultFive{}
          }
          % no
          {\ifthenelse{\equal{\howmanytext}{3}}
            % yes
            {%
            \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
              \StrGobbleRight{\resultOne}{2}[\resultOne]% removes comma
            \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
              \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
            \StrBehind[3]{\bigmessage}{-text=}[\resultThree]
            \def\resultFour{}
            \def\resultFive{}
            }
            % no
            {\ifthenelse{\equal{\howmanytext}{4}}
              % yes
              {%
              \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
                \StrGobbleRight{\resultOne}{2}[\resultOne]% removes comma
              \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
                \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
              \StrBetween[3,4]{\bigmessage}{-text=}{fn-}[\resultThree]
                \StrGobbleRight{\resultThree}{2}[\resultThree]% same...
              \StrBehind[4]{\bigmessage}{-text=}[\resultFour]
              \def\resultFive{}
              }
              % no
              {\ifthenelse{\equal{\howmanytext}{5}}
                % yes
                {%
                \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
                  \StrGobbleRight{\resultOne}{2}[\resultOne]% same...
                \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
                  \StrGobbleRight{\resultTwo}{2}[\resultTwo]% same...
                \StrBetween[3,4]{\bigmessage}{-text=}{fn-}[\resultThree]
                  \StrGobbleRight{\resultThree}{2}[\resultThree]% same...
                \StrBetween[4,5]{\bigmessage}{-text=}{fn-}[\resultFour]
                  \StrGobbleRight{\resultFour}{2}[\resultFour]% same...
                \StrBehind[5]{\bigmessage}{-text=}[\resultFive]
                }
                % no
                {}% stop here? yes while it is only in proof stage
              }
            }
          }
        }
      }
    }
    % else... there IS an ann-footnote
    {\ifthenelse{\equal{\howmanytext}{0}}
      % yes
      {%
      \def\resultOne{}
      \def\resultTwo{}
      \def\resultThree{}
      \def\resultFour{}
      \def\resultFive{}
      }
      % no
      {\ifthenelse{\equal{\howmanytext}{1}}
        % yes
        {%
        \StrBetween[1,1]{\bigmessage}{-text=}{, ann-footnote}[\resultOne]
        \def\resultTwo{}
        \def\resultThree{}
        \def\resultFour{}
        \def\resultFive{}
        }
        % no
        {\ifthenelse{\equal{\howmanytext}{2}}
          % yes
          {%
          \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
          \StrBetween[2,1]{\bigmessage}{-text=}{ann-footnote}[\resultTwo]
          \def\resultThree{}
          \def\resultFour{}
          \def\resultFive{}
          }
          % no
          {\ifthenelse{\equal{\howmanytext}{3}}
            % yes
            {%
            \StrBetween[1,2]{\bigmessage}{-text=}{fn-}[\resultOne]
            \StrBetween[2,3]{\bigmessage}{-text=}{fn-}[\resultTwo]
            \StrBetween[3,1]{\bigmessage}{-text=}{ ann-footnote}[\resultThree]
            \def\resultFour{}
            \def\resultFive{}
            }
            % no
            {\ifthenelse{\equal{\howmanytext}{4}}
              % yes
              {%
              \StrBetween[1,2]{\bigmessage}{-text=}{, fn-}[\resultOne]
              \StrBetween[2,3]{\bigmessage}{-text=}{, fn-}[\resultTwo]
              \StrBetween[3,4]{\bigmessage}{-text=}{, fn-}[\resultThree]
              \StrBetween[4,1]{\bigmessage}{-text=}{, ann-footnote}[\resultFour]
              \def\resultFive{}
              }
              % no
              {\ifthenelse{\equal{\howmanytext}{5}}
                % yes
                {%
                \StrBetween[1,2]{\bigmessage}{-text=}{, fn-}[\resultOne]
                \StrBetween[2,3]{\bigmessage}{-text=}{, fn-}[\resultTwo]
                \StrBetween[3,4]{\bigmessage}{-text=}{, fn-}[\resultThree]
                \StrBetween[4,5]{\bigmessage}{-text=}{, fn-}[\resultFour]
                \StrBetween[5,1]{\bigmessage}{-text=}{, ann-footnote}[\resultFive]
                }
                % no
                {%
                \def\resultOne{}
                \def\resultTwo{}
                \def\resultThree{}
                \def\resultFour{}
                \def\resultFive{}
                }% stop here? yes while it is only in proof stage...
              }
            }
          }
        }
      }
    }
}


% define the macro names for custom footnotes:

\def\extractFNnames{%
  \expandarg\StrCount{\bigmessage}{fn-}[\theFNnum]
  \ifthenelse{\equal{\theFNnum}{0}}
    {%
    \def\resultOneMacro{}
    \def\resultTwoMacro{}
    \def\resultThreeMacro{}
    \def\resultFourMacro{}
    \def\resultFiveMacro{}
    }% don't make any macro names
    {\ifthenelse{\equal{\theFNnum}{1}}
      {%
      \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
        \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
      \def\resultTwoMacro{}
      \def\resultThreeMacro{}
      \def\resultFourMacro{}
      \def\resultFiveMacro{}
      }
      {\ifthenelse{\equal{\theFNnum}{2}}
        {%
        \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
          \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
        \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
          \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
        \def\resultThreeMacro{}
        \def\resultFourMacro{}
        \def\resultFiveMacro{}
        }
        {\ifthenelse{\equal{\theFNnum}{3}}
          {%
          \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
            \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
          \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
            \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
          \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
            \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
          \def\resultFourMacro{}
          \def\resultFiveMacro{}
          }
          {\ifthenelse{\equal{\theFNnum}{4}}
            {%
            \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
              \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
            \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
              \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
            \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
              \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
            \StrBetween[4,4]{\bigmessage}{fn-}{-text=}[\resultFourMacro]
              \StrDel{\resultFourMacro}{-}[\resultFourMacro]% remove hyphens
            \def\resultFiveMacro{}
            }
            {\ifthenelse{\equal{\theFNnum}{5}}
              {%
              \StrBetween{\bigmessage}{fn-}{-text=}[\resultOneMacro]
                \StrDel{\resultOneMacro}{-}[\resultOneMacro]% remove hyphens
              \StrBetween[2,2]{\bigmessage}{fn-}{-text=}[\resultTwoMacro]
                \StrDel{\resultTwoMacro}{-}[\resultTwoMacro]% remove hyphens
              \StrBetween[3,3]{\bigmessage}{fn-}{-text=}[\resultThreeMacro]
                \StrDel{\resultThreeMacro}{-}[\resultThreeMacro]% remove hyphens
              \StrBetween[4,4]{\bigmessage}{fn-}{-text=}[\resultFourMacro]
                \StrDel{\resultFourMacro}{-}[\resultFourMacro]% remove hyphens
              \StrBetween[5,5]{\bigmessage}{fn-}{-text=}[\resultFiveMacro]
                \StrDel{\resultFiveMacro}{-}[\resultFiveMacro]% remove hyphens
              }
              {there must be too many}% NOTE this is a STUB
            }
          }
        }
      }
    }
}



% create the macros that are used in the messages:

\def\makeFNmacros{
  \ifthenelse{\equal{\theFNnum}{0}}
    {}% don't make any macros
    {\ifthenelse{\equal{\theFNnum}{1}}
      % yes
      {%
      \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
      }
      % no
      {\ifthenelse{\equal{\theFNnum}{2}}
        % yes
        {%
        \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
        \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }
        }
        % no
        {\ifthenelse{\equal{\theFNnum}{3}}
          % yes
          {%
          \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
          \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }
          \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
          }
          % no
          {\ifthenelse{\equal{\theFNnum}{4}}
            % yes
            {%
            \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
            \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }        \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
            \expandafter\def\csname fn\resultFourMacro\endcsname{\footnote{\resultFour} }
            }
            % no
            {\ifthenelse{\equal{\theFNnum}{5}}
              % yes
              {%
              \expandafter\def\csname fn\resultOneMacro\endcsname{\footnote{\resultOne} }
              \expandafter\def\csname fn\resultTwoMacro\endcsname{\footnote{\resultTwo} }        \expandafter\def\csname fn\resultThreeMacro\endcsname{\footnote{\resultThree} }
              \expandafter\def\csname fn\resultFourMacro\endcsname{\footnote{\resultFour} }
              \expandafter\def\csname fn\resultFiveMacro\endcsname{\footnote{\resultFive} }
              }
              % no
              {}%stop here? yes, while it is only in proof stage
            }
          }
        }
      }
    }
}



%
%%
%%%%
%%%%%
% MESSAGES

% test the message for punctuations, and store the result:

\def\annMessagePunct{}% default, no punctuation

\newcommand{\testMessagePunct}{%
  %\saveexpandmode\expandarg
    \IfEndWith{\lymessage}{.}
      % true
      {\def\annMessagePunct{.}}
      % false
      {\IfEndWith{\lymessage}{?}
        % true
        {\def\annMessagePunct{?}}
        % false
        {\IfEndWith{\lymessage}{!}
          % true
          {\def\annMessagePunct{!}}
          % false
          {\def\annMessagePunct{\unskip}}
        }
      }
  %\restoreexpandmode
}


% parse messages:
% TODO unskip ONLY if prependMessage is NOT equal to {}? Make user set that?

\newcommand{\annMessageParse}{%
  %\saveexpandmode\expandarg
    \IfEndWith{\lymessage}{.}
      % true; the user set a period for punctuation
      {\unskip\StrGobbleRight{\lymessage}{1}\nobreak}
      % false
      {\IfEndWith{\lymessage}{?}
        % true; the user set a question mark for punctuation
        {\unskip\StrGobbleRight{\lymessage}{1}\nobreak}
        % false
        {\IfEndWith{\lymessage}{!}
          % true; the user set an exclamation point for punctuation
          {\unskip\StrGobbleRight{\lymessage}{1}\nobreak}
          % false
          {\ifthenelse{\equal{\lymessage}{no value given}}{\unskip\noMessError}
            % else
            {\ifthenelse{\equal{\lymessage}{}}{\unskip\noMessError}
              % else
              {\unskip{\lymessage}\nobreak}}}
        }
      }
  %\restoreexpandmode
}


% set the append/punct vs. punct/append orientations:

\newcommand{\annMessTail}{\annMessagePunct\appendMessage} % default = Punct, Append

\newcommand{\annMessPunctAppend}{%
  \renewcommand{\annMessTail}{\annMessagePunct\unskip\appendMessage}} % Append, Punct

\newcommand{\annMessAppendPunct}{%
  \renewcommand{\annMessTail}{\appendMessage\unskip\annMessagePunct}} % Punct, Append


% generic annotation, custom type: name parser:

\def\customName{
  \StrCut{\lyanntype}{-}\splitA\splitB% remove first hyphen, if one
  \def\expandedonce{\splitA{} \splitB}
    \StrCut{\expandedonce}{-}\splitC\splitD% remove second hyphen, if two
    \def\expandedtwice{\splitC{} \splitD}
      \StrCut{\expandedtwice}{-}\splitE\splitF% remove third hyphen, if three
  \titlecap{\splitE{} \splitF}% result
}


%
%%
%%%%
%%%%%
% ANNOTATIONS

% default annotation parsers: for stacked and inline modes that can be easily
% hacked/reconfigured to custom designs.

\let\KV@errx@ORI\KV@errx% store original error handling


% critical remark:

\newcommand{\criticalRemark}[6][]{%
  % set KEYS, defaults, then new from #1
    \resetkeys
      \let\KV@errx\@gobble% ignore unknown keys
      \setkeys{scholarLYannotations}{#1}
      \let\KV@errx\KV@errx@ORI% Restore original error handling
  \saveexpandmode\expandarg
  % PARSE FOOTNOTES
    \def\bigmessage{#1}% used in fn 1, 2, 3
      \customFootsParse% parse fn, step one
      \extractFNnames% parse fn, step two
      \makeFNmacros% parse fn, step three
  % TEST MESSAGE PUNCTUATION; DEFINE measure and beat
    \testMessagePunct
    \def\currentMeasure{#2}
    \def\currentBeat{#3}
  % APPLY to ITEM
    \item{
      \preannType\annTypePfx\CRname\postannType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annMeasure{\sameMeasure}}
        {\preannArg\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\preannArg\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\preannArg\annGrobTypePfx\annAffected{#5}\skipornot}
      \preannArg\annMessagePfx{\annMessage{{%
        \prependMessageFirst\prependMessage\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip\annFootnote{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


% musical issue:

\newcommand{\musicalIssue}[6][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
      \preannType\annTypePfx\MIname\postannType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annMeasure{\sameMeasure}}
        {\preannArg\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\preannArg\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\preannArg\annGrobTypePfx\annAffected{#5}\skipornot}
      \preannArg\annMessagePfx{\annMessage{{%
        \prependMessageFirst\prependMessage\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip\annFootnote{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


% lilypond issue:

\newcommand{\lilypondIssue}[6][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
      \preannType\annTypePfx\LIname\postannType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annMeasure{\sameMeasure}}
        {\preannArg\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\preannArg\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\preannArg\annGrobTypePfx\annAffected{#5}\skipornot}
      \preannArg\annMessagePfx{\annMessage{{%
        \prependMessageFirst\prependMessage\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip\annFootnote{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


% question:

\newcommand{\annotateQuestion}[6][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
      \preannType\annTypePfx\Qname\postannType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annMeasure{\sameMeasure}}
        {\preannArg\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\preannArg\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\preannArg\annGrobTypePfx\annAffected{#5}\skipornot}
      \preannArg\annMessagePfx{\annMessage{{%
        \prependMessageFirst\prependMessage\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip\annFootnote{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


% todo:

\newcommand{\annotateTodo}[6][]{%
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
      \preannType\annTypePfx\TDname\postannType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annMeasure{\sameMeasure}}
        {\preannArg\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\preannArg\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\preannArg\annGrobTypePfx\annAffected{#5}\skipornot}
      \preannArg\annMessagePfx{\annMessage{{%
        \prependMessageFirst\prependMessage\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip\annFootnote{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


% generic annotations:

\newcommand{\annotation}[6][]{% generic annotation, for custom types
% set KEYS, defaults, then new from #1
  \resetkeys
    \let\KV@errx\@gobble% ignore unknown keys
    \setkeys{scholarLYannotations}{#1}
    \let\KV@errx\KV@errx@ORI% Restore original error handling
\saveexpandmode\expandarg
% PARSE FOOTNOTES
  \def\bigmessage{#1}% used in fn 1, 2, 3
    \customFootsParse% parse fn, step one
    \extractFNnames% parse fn, step two
    \makeFNmacros% parse fn, step three
% TEST MESSAGE PUNCTUATION; DEFINE measure and beat
  \testMessagePunct
  \def\currentMeasure{#2}
  \def\currentBeat{#3}
% APPLY to ITEM
  \item{
      \preannType\annTypePfx\customName\postannType\typeSkipornot
      \ifthenelse{\equal{#2}{\previousMeasure}}{\annMeasure{\sameMeasure}}
        {\preannArg\annLocationPfx{\annMeasure{\annMeasurePfx#2,}}}
      \ifthenelse{\equal{#2}{\previousMeasure}}
        {\ifthenelse{\equal{#3}{}}{\unskip{}}
          {\ifthenelse{\equal{#3}{\previousBeat}}{\sameBeat\skipornot}
            {\annBeat{\annBeatPfx#3}\skipornot}}}
        {\annBeat{\annBeatPfx#3}\skipornot}
      \ifthenelse{\equal{#4}{}}{\unskip{}}
        {\preannArg\annContextPfx\annVoice{#4}\skipornot}
      \ifthenelse{\equal{#5}{}}{\unskip{}}
        {\preannArg\annGrobTypePfx\annAffected{#5}\skipornot}
      \preannArg\annMessagePfx{\annMessage{{%
        \prependMessageFirst\prependMessage\annMessageParse\unskip\annMessTail}\unskip}
      \ifthenelse{\equal{\lyannfootnote}{no value given}}{}
        {\unskip\annFootnote{\footnote{\lyannfootnote}}}\appendMessageLast}}
  % set "previous" mm/beats for use in next annotation
    \def\previousMeasure{#2}
    \def\previousBeat{#3}
}


\begin{comment}

. . . . . . . . . . THIS FUNCTION NOT READY YET . . . . . . . . . . .

[The use of custom footnotes causes compilation to fail.
Function will be updated to handle custom footnotes soon enough.]

~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

% for the entirely custom command: \useCustomAnn{ ... custom stuff ... }
% NOTE this is really just a placeholder right now..

\newcommand{\customannotations}[3]{
  \expandafter{#1}
  \input{#2}
  \expandafter{#3}
}

\newcommand\useCustomAnn[1]{
  \renewcommand\criticalRemark[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\musicalIssue[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\lilypondIssue[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotateQuestion[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotateTodo[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
  \renewcommand\annotation[6][]{
    \resetkeys
      \setkeys{scholarLYannotations}{##1}
      \def\currentMeasure{##2}
      \def\currentBeat{##3}
      {#1}
      \def\previousMeasure{##2}
      \def\previousBeat{##3}
  }
}

\end{comment}

% Ignore unknown keys ... this must be last
%\makeatletter
%\let\KV@errx\@gobble
%\makeatother

\endinput
